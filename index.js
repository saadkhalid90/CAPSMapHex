async function readAndDraw(){

  // viz parameters
  const bGCol = '#173158';
  const stCol = 'none';
  const hexRad = 4;
  const stW = 2;

  const minRad = 0.7;
  const maxRad = 2;

  // change the background of the visualization
  d3.select('body')
    .style('background', bGCol);

  // read in the data generated by hexgrid
  const dataHex = await d3.json('hexData.json');

  // separate the 18 economies and Rest of Asia
  const ROAsia = dataHex.ROAsia;
  const econ18 = dataHex.econ18;

  // Preprocessing
  // add a random start to each dataset
  ROAsia.forEach(d => {
    d.randomStart = randInt(minRad, maxRad);
  });
  econ18.forEach(d => {
    d.randomStart = randInt(minRad, maxRad);
  });

  // scaling teh width and height of canvas according the retina ratio
  const ratio = getRetinaRatio();
  const width = 900;
  const height = 600;
  const scaledWidth = 900 * ratio;
  const scaledHeight = 600 * ratio;

  const canvas = d3.select('canvas.worldMap')
                  .attr('width', scaledWidth)
                  .attr('height', scaledHeight)
                  .style('width', width + 'px')
                  .style('height', height + 'px');
  const ctx = canvas.node().getContext('2d');

  ctx.scale(ratio, ratio)

  ctx.clearRect(0, 0, 900, 600);

  freq = 0.5;

  function appendHexGrid(grpName, hexVar, styleObj, time){
    for (let i = 0; i < hexVar.length; i++){
      const datum = hexVar[i];
      const timeOff = randStartToTime(freq, datum.randomStart, minRad, maxRad)
      //console.log(datum.randomStart, timeOff)
      ctx.beginPath();
      ctx.arc(datum.x, datum.y, sinOscOut(freq, time + timeOff, minRad, maxRad), 0, 2 * Math.PI);
      ctx.fillStyle = styleObj.fill;
      ctx.fill()
    }
  }

  appendHexGrid(
    'ROAsiaHex',
    ROAsia,
    {
      fill: '#3399ff',
      //fill: '#FFFF00',
      stroke: stCol,
      'stroke-width': `${stW}px`,
      'fill-opacity': 1
    },
    0
  );

  appendHexGrid(
    'NDEhex',
    econ18,
    {
      //fill: '#12471a',
      fill: '#FFFF00',
      stroke: stCol,
      'stroke-width': `${stW}px`,
      'fill-opacity': 1
    },
    0
  );

  d3.timer(function(elapsed){
    // ctx.clearRect(0, 0, 900, 600);
    // appendHexGrid(
    //   'ROAsiaHex',
    //   ROAsia,
    //   {
    //     fill: '#3399ff',
    //     //fill: '#FFFF00',
    //     stroke: stCol,
    //     'stroke-width': `${stW}px`,
    //     'fill-opacity': 1
    //   },
    //   elapsed/1000
    // );
    // appendHexGrid(
    //   'NDEhex',
    //   econ18,
    //   {
    //     //fill: '#12471a',
    //     fill: '#FFFF00',
    //     stroke: stCol,
    //     'stroke-width': `${stW}px`,
    //     'fill-opacity': 1
    //   },
    //   elapsed/1000
    // );
  });
}

readAndDraw();

function randInt(max, min){
  return min + (Math.random() * (max - min));
}

function getRetinaRatio() {
  var devicePixelRatio = window.devicePixelRatio || 1
  var c = document.createElement('canvas').getContext('2d')
  var backingStoreRatio = [
      c.webkitBackingStorePixelRatio,
      c.mozBackingStorePixelRatio,
      c.msBackingStorePixelRatio,
      c.oBackingStorePixelRatio,
      c.backingStorePixelRatio,
      1
  ].reduce(function(a, b) { return a || b })

  return devicePixelRatio / backingStoreRatio
}

function sinOscOut(freq, time, min, max){
  const range = max - min;
  const coeff = range/ 2;
  const add = max - coeff;
  return add + (coeff*(Math.sin(2 * Math.PI * freq * time)));
}

function randStartToTime(freq, output, min, max){
  const range = max - min;
  const coeff = range/ 2;
  const add = max - coeff;
  let angle = Math.asin((output - add)/ coeff);
  anglePos = angle < 0 ? angle + (2 + Math.PI) : angle;
  return (1/ (2 * Math.PI * freq)) * angle
}
